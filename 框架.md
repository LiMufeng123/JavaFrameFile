###    Spring框架中文文档

https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/overview.html#overview-spring

一个项目需要建立一个配置文件pom.xml，第一部分是mvc配置，第二部分是jdbc配置。

```
<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.3.6</version>
</dependency>



<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.3.6</version>
</dependency>


```

每个模块都要配置自己的beans文件

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

</beans>

##                         Spring框架

### 1.1、什么是Spring？

Spring框架是由于[软件开发](https://baike.baidu.com/item/软件开发/3448966)的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由[EJB](https://baike.baidu.com/item/EJB/144195)完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。

***目的是：解决企业应用开发的复杂性***

1.2、Spring框架的优点：

> Spring是一个开源的免费框架（容器）！
>
> Spring是一个轻量级的、非入侵式的框架；
>
> **控制反转（IOC），面向切面编程（AOP）！**
>
> 支持事务的处理，对框架整合的支持。

总结：Spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架！

------



![image-20210416152308618](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20210416152308618.png)

- Spring Boot

  一个快速开发的脚手架；

​	基于SpringBoot可以快速开发单个微服务；

​	约定大于配置；

- SpringCloud

​	SpringCloud是基于SpringBoot实现的。

弊端：发展太久，违背了原来的理念，配置十分繁琐，“配置地狱”。

### 2、IOC理论推导

**************Spring-Study-01文件*************

1、UserDao接口

2、UsedaoImpl实现类

3、UserService业务接口

4、UserServiceImpl业务实现类

实现逻辑：

![image-20210417095017665](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20210417095017665.png)

当程序员在底层（Dao）写了代码，不再需要修改业务层，直接在用户层修改就行，增加了代码的鲁棒性，即实现了控制反转。



IOC本质：

控制反转IOC是一种设计思想，DI（依赖注入）是实现IOC的一种方式。没有IOC的程序里，我们使用面向对象编程，对象的创建和对象间的依赖关系完全硬编码在程序中，对象的创建由程序控制，控制反转后将对象的创建转移给第三方，控制反转就是获得依赖对象的方式反转了。

控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式（上例中在用户层而不是业务层去获取新对象）。在Spring中实现控制反转的是IOC容器，其实现方式是依赖注入（Dependency Injection，DI）。



原来是程序本身创建对象，使用Spring后，对象是Spring创建的；

反转：程序本身不创建对象。而被动的接受对象；

依赖注入：引入set方法进行注入，在业务层加入set方法，可以实现用户层修改，降低业务层与底层Dao耦合度。

IOC是一种编程思想，由主动编程变为被动接收，不再new原来的对象了。

到此为止，我们不需要去程序修改了，要实现不同的操作，只需要在xml配置文件中进行修改，所谓IOC，一句话搞定，对象由Spring创建，管理，装配。

4、IOC创建对象的方式

**************Spring-Study-04文件*************

1、使用无参构造创建对象

```java
  <!--使用Spring来创建对象，在Spring这些都成为Bean
    原来创建对象的方式：
    类型  变量名    new 类型
    Hello hello = new Hello();
    现在：
    id = 变量名
    class = new的对象；
    property 相当于给对象的属性设置一个值！
    -->
<!--
    无参构造方式创建User对象
    <bean id="user" class="User">
            <property name="name" value="LiNing"/>
        </bean>
-->
```

2.1、

```java
<!--
    有参构造方式1：创建User对象，通过下标给形参列表赋值
    -->
<!--    <bean id="user" class="User">-->
<!--    <constructor-arg index="0" value="hhhh"/>-->
<!--    </bean>-->
```

2.2、

```java
<!--
有参构造方式2：创建User对象，通过形参类型给形参列表赋值
-->
<!--        <bean id="user" class="User">-->
<!--        <constructor-arg type="java.lang.String" value="hhhh"/>-->
<!--        </bean>-->
```

2.3、

```java
<!--    有参构造方式3：创建User对象，直接给各个属性赋值-->
<!--    id:bean的唯一标识符，也相当于我们学的对象名-->
<!--    name:别名，可以同时取多个-->
<!--    property:类的属性-->
    <bean id="user1" class="User" name="user2,user3">
        <constructor-arg name="name" value="hhhh"/>
    </bean>
```

总结：在配置文件加载时，容器中管理的对象就已经开始初始化了。

5、Spring配置

基本配置:每个模块配置自己的pom.xml文件，需要从进行基本配置：

```java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">


</beans>
```

5.1、别名

alias关键字

```java
<!--    起别名-->
    <alias name="user" alias="newUser"/>
```

5.2、Bean配置

```java
<!--    有参构造方式3：创建User对象，直接给各个属性赋值-->
<!--    id:bean的唯一标识符，也相当于我们学的对象名-->
<!--    name:别名，可以同时取多个-->
<!--    property:类的属性-->
    <bean id="user" class="User" name="user2,user3">
        <constructor-arg name="name" value="hhhh"/>
            <property name="name" value="Legend"/>
    </bean>
```

5.3、import

```java
<!--    import机制-->
<import resource="beans.xml"/>
<import resource="beans1.xml"/>
```

不同的程序员会根据不同需求，配置不同的beans.xml文件，那么可以通过import关键字将各个文件导入到一个文件中，进而实现汇总。

------

6、依赖注入

6.1、构造器注入

如前所述，使用构造器完成初始化操作

6.2、Set方式注入【重要】

依赖注入：Set注入！

依赖：bean对象的创建依赖于容器

注入：bean对象中的所有属性，由容器来注入！

【环境搭建】：

**************Spring-Study-05文件*************

1、复杂类型

```Java
public class Address {
    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
```

2、主类

各类属性及get/set方法+toString

```java
import java.util.*;

public class Student {
    private String name;
    private Address address;
    private String[] books;
    private List<String> hobbys;
    private Map<String,String> card;
    private Set<String> games;
    private String wife;
    private Properties info;
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public String[] getBooks() {
        return books;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", address=" + address +
                ", books=" + Arrays.toString(books) +
                ", hobbys=" + hobbys +
                ", card=" + card +
                ", games=" + games +
                ", wife='" + wife + '\'' +
                ", info=" + info +
                '}';
    }

    public void setBooks(String[] books) {
        this.books = books;
    }

    public List<String> getHobbys() {
        return hobbys;
    }

    public void setHobbys(List<String> hobbys) {
        this.hobbys = hobbys;
    }

    public Map<String, String> getCard() {
        return card;
    }

    public void setCard(Map<String, String> card) {
        this.card = card;
    }

    public Set<String> getGames() {
        return games;
    }

    public void setGames(Set<String> games) {
        this.games = games;
    }

    public String getWife() {
        return wife;
    }

    public void setWife(String wife) {
        this.wife = wife;
    }

    public Properties getInfo() {
        return info;
    }

    public void setInfo(Properties info) {
        this.info = info;
    }


}
```

3、beans环境配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

        <bean id="student"  class="Student">
<!--            property后面的name是属性名，写死的，等号右边的是对象的具体属性，value是它的值-->
<!--                第一种注入方式：注入value-->
                <property name="name"   value="LGD"/>
        </bean>
</beans>
```

3.1、值方式注入：

```xml
                <property name="name"   value="LGD"/>
```

3.2、 Bean注入：

```xml
<property name="address" ref="address"/>
```

3.3、数组注入

```xml
<property name="books">
    <array>
        <value>红楼梦</value>
        <value>水浒传</value>
        <value>三国演义</value>
    </array>
</property>
```

3.4、list注入

```xml
<property name="hobbys">
    <list>
        <value>听歌</value>
        <value>写代码</value>
    </list>
</property>
```

3.5、map注入

```xml
<property name="card">
    <map>
        <entry key="idCard" value="12345"></entry>
        <entry key="bankCard" value="54321"></entry>
    </map>
</property>
```

3.6、set注入

```xml
<property name="games">
    <set>
        <value>王者荣耀</value>
        <value>幻想三国</value>
    </set>
</property>
```

3.7、空值注入

```xml
<property name="wife">
    <null></null>
</property>
```

3.8、properties注入

```xml
<property name="info">
    <props>
        <prop key="driver">12589</prop>
        <prop key="url">5689</prop>
        <prop key="username">ln</prop>
        <prop key="password">ln827192690</prop>
    </props>
</property>
```

进行以上配置后，进行测试：

```xml
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");

        Student student = (Student) context.getBean("student");
        System.out.println(student.toString());
    }

}
```

运行结果：

Student{name='LGD', 

address=Address{address='西安'},

 books=[红楼梦, 水浒传, 三国演义], 

hobbys=[听歌, 写代码], 

card={idCard=12345, bankCard=54321}, 

games=[王者荣耀, 幻想三国], 

wife='null',

 info={password=ln827192690, driver=12589, url=5689, username=ln}}



6.3、拓展方式注入

包括p命名空间和c命名空间注入

导入：

```xml
xmlns:p="http://www.springframework.org/schema/p"
xmlns:c="http://www.springframework.org/schema/c"
```

配置：

```xml
<bean id="user" class="User" p:name="LNN"/>


<bean id="user2" class="User" c:name="ln124"/>
```

测试：

```java
public void test2(){
    ApplicationContext context = new ClassPathXmlApplicationContext("userbeans.xml");
    User user = context.getBean("user2",User.class);//利用反射，返回一个user类型对象
    System.out.println(user);

}
```

6.4、bean的作用域

*表 3. Bean 作用域*

| Scope                                                        | Description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [singleton](https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton) | (默认)将每个 Spring IoC 容器的单个 bean 定义范围限定为单个对象实例。 |
| [prototype](https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-prototype) | 将单个 bean 定义的作用域限定为任意数量的对象实例。           |
| [request](https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-request) | 将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个在单个 bean 定义后面创建的 bean 实例。仅在可感知网络的 Spring `ApplicationContext`中有效。 |
| [session](https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-session) | 将单个 bean 定义的范围限定为 HTTP `Session`的生命周期。仅在可感知网络的 Spring `ApplicationContext`上下文中有效。 |
| [application](https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-application) | 将单个 bean 定义的范围限定为`ServletContext`的生命周期。仅在可感知网络的 Spring `ApplicationContext`上下文中有效。 |
| [websocket](https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-websocket-scope) | 将单个 bean 定义的范围限定为`WebSocket`的生命周期。仅在可感知网络的 Spring `ApplicationContext`上下文中有效。 |

单例模式：（Spring默认机制）

```xml
<bean id="user2" class="User" c:name="ln124" scope="singleton"/>
```

在scope后加入singleton关键字，表示该类的示例只会被创建一次。看下面的测试：

```java
public void test2(){
    ApplicationContext context = new ClassPathXmlApplicationContext("userbeans.xml");
    User user = context.getBean("user2",User.class);//利用反射，返回一个user类型对象
    User user2 = context.getBean("user2",User.class);//利用反射，返回一个user类型对象
    System.out.println(user==user2);

}
返回true
```



原型模式：

```xml
    <bean id="user2" class="User" c:name="ln124" scope="prototype"/>
```

在scope后加入singleton关键字，表示该类的示例只会被创建一次。看下面的测试：

```java
public void test2(){
    ApplicationContext context = new ClassPathXmlApplicationContext("userbeans.xml");
    User user = context.getBean("user2",User.class);//利用反射，返回一个user类型对象
    User user2 = context.getBean("user2",User.class);//利用反射，返回一个user类型对象
    System.out.println(user==user2);

}
返回false
```

7、Bean的自动装配



自动装配是Spring满足bean依赖的一种方式。

Spring会在上下文中自动寻找，并自动给bean装配属性。



在Spring中有三种装配方式：

1、在xml中显示的配置；

2、在java中显示配置；

3、隐式的自动装配bean【important】

7.1、测试

环境搭建：一个人有两个宠物；

7.2、byName自动装配

```xml
<bean id="people" class="People" autowire="byName">
<!--   <property name="name" value="LNN" ></property>-->
<!--   <property name="dog" ref="dog"></property>-->
<!--       <property name="cat" ref="cat"></property>-->
<!--        -->
<!--        <property name="giao" ref="giao"></property>-->
    </bean>
```

7.3、byType自动装配

```xml
<bean id="people" class="People" autowire="byType">
```

这种方式可以随意指定id值，只按类型检索。

总结：

> `byName的时候，需要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法值一致`
>
> ``byType的时候，需要保证所有的bean的类唯一，并且这个bean需要和自动注入的属性的类型一致``

7.4、使用注解方式装配

